Grounded Function Network (GrFN) JSON Specification - v0.1.m3
=============================================================

Introduction
------------

GrFN, pronounced "Griffin", is the specification format for the central
representation that integrates the extracted Function Network
representation of source code (the result of program analysis) and
associated extracted comments, links to natural language text (the
result of natural language processing), and links to equations (the
result of equation extraction).

### Specification conventions

This document describes the GrFN JSON schema, specifying the JSON format 
that is to be generated by program analysis and consumed by Delphi.

In this document we adopt a simplified [Backus-Naur Form
(BNF)](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form)-inspired
grammar convention combined with a convention for intuitively defining
specific JSON attribute-value lists. The schema definitions and instance
GrFN examples are shown in `monospaced font`, and interspersed with
comments/discussion.

Following BNF convention, elements in `<...>` denote nonterminals, with
`::=` indicating a definition of how a nonterminal is expanded. We will 
use some common nonterminals with standard expected interpretations, such
as `<string>` for strings, `<integer>` for integers, etc. Many of the 
definitions below will specify JSON attribute-value lists; when this
is the case, we will decorate the nonterminal element definition by adding
`[attrval]`, as follows::

    <element_name>[attrval] ::= 

We will then specify the structure of the JSON attribute-value list
attributes (quoted strings) and their value types using a mixture of
[JSON](https://www.json.org/) and 
[BNF](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form).

We also use the following conventions in the discussion below:
- \'FUTURE\': tags anticipated extensions that may be needed but not yet 
supported.
- \'CHOICE\' followed by \'FOR NOW\': Captures discussion of a CHOICE that 
does not yet have a clear resolution, but what we are doing FOR NOW.

### From source code to dynamic system representation

The goal of GrFN is to provide the end-point target for a translation from the semantics of program (computation) specification (as asserted in source code) to the semantics of a (discretized) dynamic system model.

A key assumption is that the program source code we are analyzing is intended to model aspects of some target physical domain, and that this target physical domain is a dynamical system that evolves over time.

The system is decomposed into a set of individual states (represented as random variables), where the values of the states at any given time are a function of the values of zero or more other states at the current and/or previous time point(s). Because we are considering the evolution of the system over time, in general every variable has an index. The functional relationships may be instantaneous (based on the variables indexed at the same point in time) or a function of states of variables at different time indices.

Identifiers: Grounding, Scopes, Namespaces and Gensyms
------------------------------------------------------

Identifiers are symbols used to uniquely identify a program element in code, where a *program element* is a 
- variable (or constant)
- function
- type (class)

More than one identifier can be used to denote the same program element, but an identifier can only be associated with one program element at a time.

### Grounding

Identifiers play a key role in connecting the model as implemented in source code to the target domain that it models. *Grounding* is the task of inferring what aspect of target domain a program element may correspond to, and identifiers, by their (base) name(s), their declaration and use (where they occur in code -- `scope` and `namespace`), and the doc and comment strings that occur around them, provide clues to what they are intended to refer to. For this reason, we need to associate with identifiers several pieces of information. This information will be collected during program analysis and associated with the identifier declaration:

- "aliases": It is possible for multiple identifiers to be used to denote the same program element. How this is done differs across languages, according to scoping rules and assignment. Program analysis modules for each language (e.g., the Fortran `for2py` analyzer) will determine this. One general way to assign more than one identifier to the same program element is through a *simple equality assignment*, e.g.: `y = x` means that a new identifier, `y`, denotes the same program element that `x` does. A simple equality assignment just involve one identifier being equated with another, no other operations are applied; if other operations are applied (e.g., `y = x + 1`), then this is a *new* identifier as it does not represent the original value of `x` but a modification of it.

    CHOICE: Do we declare each identifier separately, or combine them at program analysis time to the a single identifier with aliases.
    FOR NOW: We will only keep track of a single identifier (the first one encountered by program analysis) but associate any additional `aliases` as the names of any additional identifier introduced in code.
	
- "source_references": To facilitate later grounding inference, we will store a reference to the location within the source code where an identifier is declared, using a `<source_code_reference>`:

    <source_code_reference> := <string>

    The string contains information to identify the location of the identifier, which is a single line number if the declaration occurs on a single line, otherwise two line numbers to indicate the span of line numbers containing the declaration. (`<soure_code_references>` will be used to represent the location of other program elements, such as for functions, below.)

    Because an identifier may have associated aliases, the "source_references" will be a list of one or more `<source_code_reference>`, with one `<source_code_reference>` representing the location in source code of the initial identifier declaration, and then an additional `<source_code_reference>` for each time a new alias is initially declared (e.g., through an assignment). The order of these `<source_code_reference>`s will correspond the order of the introduction/declaration of the aliases in the source code (from the perspective of program analysis). (The reason for this is that the initial introduction of the alias is more likely to have associated relevant comments that might provide information about the identifier's grounding.)

### Base name

The `base_name` is intended to correspond to the identifier token name as it appears in the source language (e.g., Fortran). The `<lang_string>` is itself a string

    <lang_string> ::= <string>

but follows the conventions of [python identifier specification rules](https://docs.python.org/3/reference/lexical_analysis.html#identifiers) (which includes Fortran naming syntax). (FUTURE: may extend this as more source languages are supported.)

### Scope and namespace paths

Identifiers may have the same `base_name` (as it appears in source code) but be distinguished by either (or both) the [scope](https://en.wikipedia.org/wiki/Scope_(computer_science)) and [namespace](https://en.wikipedia.org/wiki/Namespace) within which they are defined in the source code.

Each source language has its own rules for specifying `scope` and `namespace`, and it will be the responsibility of each program analysis module (e.g., Fortran `for2py`) to identify the hierarchical structure of the context that uniquely identifies the specific `scope` and/or `namespace` within which an identifier `base_name` is defined. However, generally `scope`s and `namespace`s may be defined hierarchically, such that the name for each level of the hierarchy taken together uniquely define the context. A `path` of names appears to be sufficient to generally represent the hierarchical context for either a specific `scope` or `namespace`. In general, a names for a `path` are listed in order from general (highest level in the hierarchy) to specific.

Examples:

- `scope`: As will be described below, program analysis will assign unique names for scopes (see discussion below under conditional, container and loop_plate). Given these names, the scope of the inner loop within the function `foo` in this example,
    ```
    def foo():
        for i in range(10):      # assigned unique name 'loop1'
        	for j in range(10):  # assigned unique name 'loop2'
        		x = i*j
    ```
    would be uniquely specified by the following path:
    ```
    ["foo", "loop1", "loop2"]
    ```
    
    In general, it is not necessary within GrFN to independently declare `scope`s for use in multiple places. Instead, we simply specify the `<scope_path>` as a list of strings under the "scope" attribute in the identifier declaration (below).
    
    <scope_path> ::= list of <string>
    
- `namespace`: a namespace may be explicitly defined within source code by namespace declarations, or implicitly defined by the project directory structure within which a file is located. In the case of project directory structure, two files in different locations in the project directory tree may have the same name. To distinguish these, program analysis will capture the path of the directory tree from the root to the file. For example, the namespace for file `baz.py` within the following directory tree
    ```
    foo/
        bar/
            baz.py
    ```
    would be the uniquely specified by the following path:
    ```
    ["foo", "bar", "baz"]
    ```

    Again, it is not necessary within GrFN to independently declare a `namesapce`; like the `<scope_path>`, we specify the `<namespace_path>` within an identifier declaration as a list strings under the "namespace" attribute in the identifie declaration:
	
    <namespace_path> ::= list of <string>
    
    Like the `<scope_path>`, the string names of the path uniquely defining the namespace are in in order from general to specific, with the last string name either being the implicit namespace defined by the source code file, or the user-defined name of the namespace.

#### Path strings

It will be convenient to be able to express `<scope_path>`s and `<namespace_path>`s using single strings within GrFN (particularly when building an identifier string). For this we introduce a special string notation in which the string names that make up a path are expressed in order but separated by periods. These representations will be referred to as the `<scope_path_string>` and `<namespace_path_string>`, respectively. The string representations of the `<scope_path>` and `<namespace_path>` examples above would be:

- Example `<scope_path_string>`: "foo.loop1.loop2"

- Example `<namespace_path_string>`: "foo.bar.baz"

### Identifier string

Identifiers are uniquely defined by their `base_name`, `scope`, and `namespace`. It will be convenient to refer to any identifier using a single string. Here we combine the `namespace`, `scope` and `base_name` (in that order) within a single string by separating the `<namespace_path_string>`, `<scope_path_string>` and `base_name` by double-colons: '::':

    <identifier_string> ::= "<namespace_path_string>::<scope_path_string>::base_name"

### Identifier gensym

>TODO

### Identifier declaration

Each identifier within a GrFN specification will have a single `<identifier>` declaration, and `<identifier_string>`s are then used to denote uses of the identifier elsewhere in the GrFN spec. An identifier will be declared in the GrFN spec JSON by the following attribute-value list:

    <identifier>[attrval] ::=
        "base_name" : <lang_string>
        "scope" : <scope_path>
        "namespace" : <namespace_path>
        "aliases" : list of <string>
        "source_references" : list of <source_code_reference>
        "gensym" : <gensym>

Variable and function identifiers and references
------------------------------------------------

### Variable naming convention

A variable name will be an identifier:

    <variable_name> ::= <identifier_string>

A top level source variable named ABSORPTION would then simply have the `base_name` of "ABSORPTION" plus the relevant `<namespace_path_string>` and `<scope_path_string>`.

If there are two (or more) separate instances of new variable declarations in the same context (same namespace and scope) using the same name, then we'll add an underscore and number to the `base_name` to distinguish them. For example, if ABSORPTION is defined twice in the same namespace and scope, then the `base_name` of the first (in order in the source code) is named:

    "ABSORPTION_1"

And the second:

    "ABSORPTION_2"

### Variable Reference

    <variable_reference>[attrval] ::= 
        "variable" : <variable_name>
        "index" : <integer>

In addition to capturing source code variable environment context in variable declarations, we also need a mechanism to disambiguate specific instances of *use* of the same variable within the same context to accurately capture the logical order of variable value updates. In this case, we consider this as a repeated reference to the same variable. The semantics of repeated reference is captured by the variable \"index\" attribute of a `<variable_reference>`. The index integer serves to disambiguate the execution order of the variable state references, as determined during program analysis.

### Function naming conventions

Function names, like variable names, are ultimately identifiers, but there are special rules for determining the `base_name`. 

>Also like variable names, they should be legal Python function names that could show up in working Python code (as will be the case when used in Lambda function references; see below). 

The general string format for a function `base_name`:

    <function_type>__[ <base_name> | <assigned_name> ][___<var_affected>]

Similar to variable naming, we need to use the function name string to
uniquely identify the function, and as some functions extracted by
program analysis will be expressions defined within other functions
(loops and conditions), we need to capture the \"context\" in which the
function is defined. The `<enclosing_context>` represents the source
code environment context within which the function is defined. When a
function is declared at the \"top level\" (as will often be the case for
container functions), the `<enclosing_context>` is just the \"top
level\" and so is empty. Assigns, conditions and loop\_plates, however,
will often be declared within another source code function. In those
cases, the `<enclosing_context>` capture the enclosing function name.
For example, for an assignment within the UPDATE\_EST function, the
`<enclosing_context>` is \"UPDATE\_EST\".

Next, the `<function_type>` is the string representing which of the four
types the function belongs to (the types are described in more detail,
below): \"assign\", \"condition\", \"container\", \"loop\_plate\". In
the case of a loop\_plate, we will name the specific loop using the
generic name \"loop\", and include a number if there is more than one
loop.

Finally, `<var_affected>` will only be relevant for assign and condition
function types, and the name of the variable affected will be added
after the `<function_type>` and 3 underscores. For example, a condition
variable occurring within the function UPDATE\_EST function and setting
the (inferred) boolean variable IF\_1 would have the name:
`"UPDATE_EST__condition___IF_1"`.

Here are example function names for each function types:

-   **Assign**: An assignment of the variable UPDATE\_EST\_\_YIELD\_EST
    in the context of function UPDATE\_EST:

        UPDATE_EST__assign___UPDATE_EST__YIELD_EST

-   **Condition**: A condition within the function UPDATE\_EST assigning
    the (inferred) boolean variaaible IF\_1:

        UPDATE_EST__condition___IF_1

-   **Container**: A container function called CROP\_YIELD:

        CROP_YIELD__container

-   **Loop_plate**:
    -   A single loop within the function CROP\_YIELD:

            CROP_YIELD__loop

    -   The third of three loops within the function CROP\_YIELD:

            CROP_YIELD__loop_3

    -   A loop nested in the context of another loop in CROP\_YIELD::

            CROP_YIELD__loop_1__loop_2

    -   An assignment within a single loop in CROP\_YIELD:

            CROP_YIELD__loop__assign___CROP_YIELD__RAIN

NOTE: There is some redundancy in the above examples between the
`<enclosing_context>` of the name of the function and the
`<enclosing_context>` of the name of the variable, however both are
needed to unambiguously refer to the specific function and the
specific variable (by their enclosing contexts).

Top-level GrFN specification
----------------------------

The top-level structure of the GrFN is the `<grfn_spec>` and is itself a
JSON attribute-value list, with the following schema definition:

    <grfn_spec>[attrval] ::=
        "start": <string>
        "name" : <string>
        "dateCreated" : <string>
        "functions" : list of <function_spec>

The \"start\" attribute holds the name of the entry point of the
(Fortran) source code i.e. the PROGRAM module. In the absence of this
module, this string will remain empty. The \"name\" attribute is used
to denote the (Fortran) source code that has been analyzed. The
\"dateCreated\" attribute is a string representing the date+time that
the current GrFN was generated (this helps resolve what version of the
program analysis code (e.g., for2py) was used).

FUTURE:

- We may need to extend \"name\" value to accommodate multiple source
  files. 
- It may also be desirable to add an attribute to represent
  the program analysis code version used to generate the GrFN (as
  presumably the program analysis code could evolve and have different
  properties) \-- although \"dateCreated\" may be sufficient.

A (partial) example instance of a JSON attribute-value list generated
following the `<grfn_spec>`:

```javascript
{
    "start": "MAIN"
    "name": "crop_yield.py",
    "dateCreated": "20180623",
    "functions": [... function_specs go here...]
}
```

Variable specification
----------------------

    <variable_spec>[attrval] ::=
        "name" : <variable_name>
        "domain" : <variable_domain_type>

The purpose of the list of `<variable_spec>`\'s in the \<grfn\_spec\>
\"variables\" attribute value is to list all of the variables defined
within the code we are analyzing, and associate each with their domain
type. This list should include all variables whose values get updated by
computation, and will be derived from variables that are explicitly
asserted in source code, such as those used for explicit value
assignment or used as loop indices, and other variables that program
analysis may introduce (infer) as part of analyzing conditionals.

### Variable value domain

    <variable_domain_type> ::= <string>

The \"domain\" attribute of a `<variable_spec>` specifies what values
the variable can be assigned to. To start, we will keep things simple
and restrict ourselves to four types that can be specified as strings:

-   \"real\" (i.e. a floating-point number)
-   \"integer\"
-   \"boolean\"
-   \"string\"

(The idea of the variable domain is intended to be close to the idea of
the \"support\" of a random variable, although should also correspond to
standard data types.)

TODO: Need to extend to accommodate arrays.

FUTURE:

-   May also need to accommodate other structures (How far can this go?
    Unions, composite data structures, classes?).
-   We see augmenting the domain specification to also allow
    representing whether there are bounds on the values (e.g., positive
    integers, or real values in (0,10\], etc.). When we move to doing
    this, the value of \"domain\" will itself become a new JSON attrval
    type.

Python is a strongly-typed language, but is also a dynamically typed
language. However, that\'s not to say that there is no type
specification in Python. Python 3 now provides nascent support for
explicit typing via [type
hints](https://docs.Python.org/3/library/typing.html).

TODO: Explore whether/how this gets represented in the AST.

For our purposes in the near term, we do want to capture what type and
value-domain information is available; there are two main sources of
this information:

1.  **Fortran**: Does statically specify types. If we also want to
    capture this in program-analysis-generated code, then there is
    question of how to communicate this in the Python source
    representation; possibly through the new typing mentioned above;
    possibly as docstrings in program-analysis-generated code.
2.  **Docstrings**: Possibly types and value ranges can be inferred from
    what is specified in a docstring.

### \<variable\_spec\> examples

Here are three examples of `<variable_spec>` objects:

-   Example of a \"standard\" variable MAX\_RAIN within the CROP\_YIELD
    function:

    ```javascript
    {
        "name": "CROP_YIELD__MAX_RAIN",
        "domain": "real"
    }
    ```

-   Example of loop index variable DAY in the context of the second
    instance of a loop in the function CROP\_YIELD

    ```javascript
    {
        "name": "CROP_YIELD__LOOP_2__DAY"
        "domain": "integer"
    }
    ```

-   Example of variable introduced (inferred) when analyzing a
    conditional statement that is within the named function UPDATE\_EST:

    ```javascript
    {
        "name": "IF_1"
        "domain": "boolean"
    }
    ```

Note that we do not include the `<enclosing_context>` of the UPDATE\_EST
function in this case, as this is an inferred conditional boolean
variable (per our naming convention, described above).

Function specification
----------------------

Next we have the `<function_spec>`. There are four types of functions;
two types can be expressed using the same attributes in their JSON
attribute-value list (`<function_assign_spec>`), while the others
(`<function_container_spec>`, `<function_loop_plate>`) require different
attributes. So the means there are three specializations of the
\<function\_spec\>, one of which (`<function_assign_spec>`) will be used
for two function types.:

    <function_spec> ::=
        <function_assign_spec>     # either type "assign" or "condition:
    | <function_container_spec> # type "container"
    | <function_loop_plate>     # type "loop_plate"

All three specs will have a \"type\" attribute that will unambiguously
identify which type of function is being specified. The four possible
types are:

-   \"assign\"
-   \"condition\" (a special case of \"assign\")
-   \"container\"
-   \"loop\_plate\"

All \<function\_spec\>s will also have a name attribute with a unique
string value (across \<function\_spec\>s), as described above under the
Function naming convention section; as described in that section, the
function name will include the function type, but having the explicit
type attribute make parsing easier.

### Function Assign Specification
---------------------------------

A `<function_assign_spec>` denotes the setting of the value of a
variable. The values are assigned to the \"target\" variable (denoted by
a `<variable_reference>` or `<variable_name>`) and the value is
determined by the \"body\" of the assignment, which itself may either be
a literal value (specified by `<function_assign_body_literal_spec>`) or
a lambda function (specified by `<function_assign_body_lambda_spec>`).:

    <function_assign_spec>[attrval] ::=
        "name" : <function_name>
        "type" : "assign" | "condition" # note that either is a literal/terminal value 
                                        # of the grammar
        "sources" : list of [ <function_source_reference> | <variable_name> ]
        "target" : <function_source_reference> | <variable_name>
        "body" : <function_assign_body_literal_spec> 
            | <function_assign_body_lambda_spec>

In the general case of variable assignment/setting, the attribute type
should be \"assign\". In the special case where we are representing the
assignment of a boolean value as the result of a condition
(if-statement), then program analysis will infer a new boolean target
variable, and the computation of the condition itself will be
represented by the assignment function; in this case, we will use the
more specific \"condition\" value for the \"type\" attribute of the
`<function_assign_spec>`. Semantically, this is nothing more than an
assignment of a boolean variable, but conceptually it will be useful to
distinguish assignments used for conditions from other assignments.

For \"sources\" and \"target\": when there is no need to refer to the
variable by its relative index, then `<variable_name>` is sufficient,
and index will be assumed to be 0 (if at all relevant). In other cases,
the variables will be referenced using the
`<function_source_reference>`. There may also be cases where the sources
can be a function, either built-in or user-defined. These two will be
referenced using `<function_source_reference>` defined as:

    <function_source_reference> ::=
       "name" : [ <variable_name> | <function_name> ]
       "type" : "variable" | "function"

#### Function assign body Literal

The `<function_assign_body_literal_spec>` asserts the assignment of a
`<literal_value>` to the target variable. The `<literal_value>` has a
data type (corresponding to one of our four domain types), and the value
itself will be represented generically in a string (the string will be
parsed to extract the actual value according to its data type).:

    <function_assign_body_literal_spec>[attrval] ::=
        "type" : "literal"
        "value" : <literal_value>

    <literal_value>[attrval] ::=
        "dtype" : "real" | "integer" | "boolean" | "string"
        "value" : <string>

#### Function assign body Lambda

When more computation is done to determine the value that is being
assigned to the variable in the `<function_assign_spec>`, then
`<function_assign_body_lambda_spec>` is used.:

    <function_assign_body_lambda_spec>[attrval] ::=
        "type" : "lambda"
        "name" : <function_name>
        "reference" : <source_code_reference>

Eventually, we can expand this part of the grammar to accommodate a
restricted set of arithmetic operations involved in computing the final
value (this is now of interest in the World Modelers program and we\'re
interested in supporting this in Delphi). But for now, we will start by
having the lambda function reference the source code that does the
computation, in the translated Python generated by program analysis. Any
variables that are involved in the computation must be listed in the
\"source\" list of variables (\<variable\_name\> references) in the
\<function\_assign\_spec\>.

### Function Decision Specification

Handles representation of simple binary condition block::

    If condition_variable:
        Condition1 variable_reference
    Else

### Function Container Specification

A `<function_container_spec>` is the generic, \"top level\" way to
specify how a set of variables that are related by functions are \"wired
up\" by those functions. (I previously referred to this as the \"top\",
but here I\'m renaming it a \"container\" as that\'s more descriptive of
how it functions.):

    <function_container_spec>[attrval] ::=
        "name" : <function_name>
        "type" : "container"
        "DOCS" : <STRING>
    "input" : list of [ <variable_reference> | <variable_name> ]
        "variables" : list of <variable_spec>
        "output" : list of <variable_reference> | <variable_name>
        "body" : list of <function_reference_spec>

Case 1: subroutine

```python
def foo1_subroutine(x,y):
    x = y

def foo2_subroutine():
    Integer z, y, w
    y = 5
    foo1(z,y)
    foo1(w,y)
```

now z = 5 and w = 5

Case 2: fortran function with simple return

```python
def foo():
    x <-
    return x

def foo2():
    y = foo()
```

Case 3: fortran function with return expression

```python
def foo():
    return x+1
```

becomes\...

```python
def foo():
  foo_return1 = x+1

return foo_return1
```

Case 4: conditional return statements

```python
def foo(): #fortran function
    if(x):
        return x
    else:
        return y
```

There will be a container function for each source code function. For
this reason, we need an \"input\" variable list (of 0 or more variables)
as well as an \"output\" variable. In Python, a function only returns a
value if there is an explicit return expression. Otherwise it returns
None.

TODO: Can there be nested functions in Fortran?

### Function Reference Specification

    <function_reference_spec>[attrval] ::=
        "function" : <function_name>
        "input" : list of [ <variable_reference> | <variable_name> ]
        "output" : <variable_reference> | <variable_name>

The `<function_reference_spec>` defines the \"wiring\" between functions
and their input and output variable(s).

### Function Loop Plate Specification

    <function_loop_plate>[attrval] ::=
        "name" : <function_name>
        "type" : "loop_plate"
        "input" : list of <variable_name>
        "index_variable" : <variable_name>
        "index_iteration_range" : <index_range>
        "body" : list of <function_reference_spec>

The \"input\" list of `<variable_name>` objects should list all
variables that are set in the scope outside of the loop\_plate.

The \"index\_variable\" is the named variable that stores the iteration
state of the loop; the naming convention of this variable is described
above, in the Variable naming convention section. The only new element
introduced is the `<index_range>`::

    <index_range>[attrval] ::=
        "start" : <integer> | <variable_reference> | <variable_name>
        "end" : <integer> | <variable_reference> | <variable_name>

This definition permits loop iteration bounds to be specified either as
literal integers, or as the values of variables.

TODO: we think Fortran is restricted to integer values for iteration
variables, which would include iteration over indexes into arrays. Need
to double check this.
